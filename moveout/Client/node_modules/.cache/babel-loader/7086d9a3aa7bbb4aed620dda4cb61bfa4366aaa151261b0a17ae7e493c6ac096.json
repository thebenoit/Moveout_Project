{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.maybeAddIdToDocuments = exports.indexInformation = void 0;\nasync function indexInformation(db, name, options) {\n  if (options == null) {\n    options = {};\n  }\n  // If we specified full information\n  const full = options.full == null ? false : options.full;\n  // Get the list of indexes of the specified collection\n  const indexes = await db.collection(name).listIndexes(options).toArray();\n  if (full) return indexes;\n  const info = {};\n  for (const index of indexes) {\n    info[index.name] = Object.entries(index.key);\n  }\n  return info;\n}\nexports.indexInformation = indexInformation;\nfunction maybeAddIdToDocuments(coll, docOrDocs, options) {\n  const forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : coll.s.db.options?.forceServerObjectId;\n  // no need to modify the docs if server sets the ObjectId\n  if (forceServerObjectId === true) {\n    return docOrDocs;\n  }\n  const transform = doc => {\n    if (doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n    return doc;\n  };\n  return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);\n}\nexports.maybeAddIdToDocuments = maybeAddIdToDocuments;","map":{"version":3,"names":["indexInformation","db","name","options","full","indexes","collection","listIndexes","toArray","info","index","Object","entries","key","exports","maybeAddIdToDocuments","coll","docOrDocs","forceServerObjectId","s","transform","doc","_id","pkFactory","createPk","Array","isArray","map"],"sources":["/Users/jerrybenoit/Desktop/Moveout_Project/moveout/node_modules/mongodb/src/operations/common_functions.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport type { Db } from '../db';\nimport type { ReadPreference } from '../read_preference';\nimport type { ClientSession } from '../sessions';\n\n/** @public */\nexport interface IndexInformationOptions {\n  full?: boolean;\n  readPreference?: ReadPreference;\n  session?: ClientSession;\n}\n/**\n * Retrieves this collections index info.\n *\n * @param db - The Db instance on which to retrieve the index info.\n * @param name - The name of the collection.\n */\nexport async function indexInformation(db: Db, name: string): Promise<any>;\nexport async function indexInformation(\n  db: Db,\n  name: string,\n  options?: IndexInformationOptions\n): Promise<any>;\nexport async function indexInformation(\n  db: Db,\n  name: string,\n  options?: IndexInformationOptions\n): Promise<any> {\n  if (options == null) {\n    options = {};\n  }\n  // If we specified full information\n  const full = options.full == null ? false : options.full;\n  // Get the list of indexes of the specified collection\n  const indexes = await db.collection(name).listIndexes(options).toArray();\n  if (full) return indexes;\n\n  const info: Record<string, Array<[string, unknown]>> = {};\n  for (const index of indexes) {\n    info[index.name] = Object.entries(index.key);\n  }\n  return info;\n}\n\nexport function maybeAddIdToDocuments(\n  coll: Collection,\n  docs: Document[],\n  options: { forceServerObjectId?: boolean }\n): Document[];\nexport function maybeAddIdToDocuments(\n  coll: Collection,\n  docs: Document,\n  options: { forceServerObjectId?: boolean }\n): Document;\nexport function maybeAddIdToDocuments(\n  coll: Collection,\n  docOrDocs: Document[] | Document,\n  options: { forceServerObjectId?: boolean }\n): Document[] | Document {\n  const forceServerObjectId =\n    typeof options.forceServerObjectId === 'boolean'\n      ? options.forceServerObjectId\n      : coll.s.db.options?.forceServerObjectId;\n\n  // no need to modify the docs if server sets the ObjectId\n  if (forceServerObjectId === true) {\n    return docOrDocs;\n  }\n\n  const transform = (doc: Document): Document => {\n    if (doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  };\n  return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);\n}\n"],"mappings":";;;;;;AAwBO,eAAeA,gBAAgBA,CACpCC,EAAM,EACNC,IAAY,EACZC,OAAiC;EAEjC,IAAIA,OAAO,IAAI,IAAI,EAAE;IACnBA,OAAO,GAAG,EAAE;;EAEd;EACA,MAAMC,IAAI,GAAGD,OAAO,CAACC,IAAI,IAAI,IAAI,GAAG,KAAK,GAAGD,OAAO,CAACC,IAAI;EACxD;EACA,MAAMC,OAAO,GAAG,MAAMJ,EAAE,CAACK,UAAU,CAACJ,IAAI,CAAC,CAACK,WAAW,CAACJ,OAAO,CAAC,CAACK,OAAO,EAAE;EACxE,IAAIJ,IAAI,EAAE,OAAOC,OAAO;EAExB,MAAMI,IAAI,GAA6C,EAAE;EACzD,KAAK,MAAMC,KAAK,IAAIL,OAAO,EAAE;IAC3BI,IAAI,CAACC,KAAK,CAACR,IAAI,CAAC,GAAGS,MAAM,CAACC,OAAO,CAACF,KAAK,CAACG,GAAG,CAAC;;EAE9C,OAAOJ,IAAI;AACb;AAnBAK,OAAA,CAAAd,gBAAA,GAAAA,gBAAA;AA+BA,SAAgBe,qBAAqBA,CACnCC,IAAgB,EAChBC,SAAgC,EAChCd,OAA0C;EAE1C,MAAMe,mBAAmB,GACvB,OAAOf,OAAO,CAACe,mBAAmB,KAAK,SAAS,GAC5Cf,OAAO,CAACe,mBAAmB,GAC3BF,IAAI,CAACG,CAAC,CAAClB,EAAE,CAACE,OAAO,EAAEe,mBAAmB;EAE5C;EACA,IAAIA,mBAAmB,KAAK,IAAI,EAAE;IAChC,OAAOD,SAAS;;EAGlB,MAAMG,SAAS,GAAIC,GAAa,IAAc;IAC5C,IAAIA,GAAG,CAACC,GAAG,IAAI,IAAI,EAAE;MACnBD,GAAG,CAACC,GAAG,GAAGN,IAAI,CAACG,CAAC,CAACI,SAAS,CAACC,QAAQ,EAAE;;IAGvC,OAAOH,GAAG;EACZ,CAAC;EACD,OAAOI,KAAK,CAACC,OAAO,CAACT,SAAS,CAAC,GAAGA,SAAS,CAACU,GAAG,CAACP,SAAS,CAAC,GAAGA,SAAS,CAACH,SAAS,CAAC;AACnF;AAvBAH,OAAA,CAAAC,qBAAA,GAAAA,qBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}